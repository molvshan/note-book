# 栈空间和堆空间
## Javascript语言类型
`javascript`是一种**弱类型**、**动态语言**

* 在声明变量时，需要确认其数据类型的被称为**静态语言**，相反的，则为**动态语言**
* 支持隐式类型转换的语言被称为**弱类型语言**，相反的，则为**强类型语言**

## JavaScript数据类型
| 类型 | 描述 |
| -- | -- |
| Boolean | `true / false` |
| Null | `null` |
| Undefined | 一个没有被赋值的变量会被默认为`undefined`，变量提升时的默认置也是`undefined` |
| Number | 数字类型 |
| BigInt | 一个全新的数字类型，可以用任意精度表示整数。使用`BigInt`，即使超出Number的安全整数范围限制也可以安全的存储和操作 |
| String | 字符串类型 |
| Symbol | 符号类型，唯一并且不可修改，通常用作`Object`的`Key` |
| Object | 一组属性的集合 |
*注意：使用`typeof`处理`null`时，返回的是`object`*

## 内存空间
`JavaScript`执行过程中有三种类型的内存空间，分别是**代码空间**、**栈空间**和**堆空间**。

* 栈空间就是指`javaScript`中的函数调用栈，原始类型的数据值是直接保存在栈空间中的
* 引用类型的值保存在堆空间中
* 原始类型的值赋值，会完整复制变量值，而引用类型的赋值则是复制引用地址（指针）

## 闭包数据存储
在`javaScript`运行编译过程中，如果遇到存在内部函数，则`javaScript`引擎会对内部函数做一次快速词法扫描。如果扫描发现内部函数中有引用外部函数的变量，则会认为这是一个闭包，并且在堆空间创建一个`closure`对象用来保存闭包数据。所以**闭包数据是保存在堆空间中的**。

---

# 垃圾回收

> 通常情况下，垃圾回收分为**手动回收**和**自动回收**两种策略。`JavaScript`使用自动回收策略
如果一个数据使用完毕，但是却没有被回收，这种情况被称为**内存泄漏**。

## 调用栈中的数据回收

在调用栈中，当一个函数执行结束之后，**JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文**

> **ESP**指记录当前执行状态的指针

以以下代码为例分析：
```javascript
function foo(){
  var a = 1 
  var b = {name:"极客邦"} 
  function showName(){ 
    var c = 2 从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。
    var d = {name:"极客时间"} 
  } 
  showName()
}
foo()
```
当`showName`方法执行完毕之后，函数调用栈如下图所示：
@import "../images/delete1.jpg"

从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。


## 堆中的数据回收

V8中会把堆分为**新生代**和**老生代**两个区域
* 新生代：容量小（通常为1~8M），存放生存时间短的对象
* 老生代：容量大，存放生存时间久的对象。

两块区域使用不同的垃圾回收器，新生代区域使用**副垃圾回收器**，老生代区域使用**主垃圾回收器**

### 垃圾回收流程：
* 标记空间中活动对象和非活动对象。活动对象是还在使用中的对象，非活动对象是可以进行垃圾回收的对象
* 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象
* 做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，这些不连续的空间被称为**内存碎片**。当内存中出现大量内存碎片后，如果需要分配较大连续内存时，就可能出现内存不足的情况。所以，最后一步需要整理这些内存碎片。


### 副垃圾回收器
> 新生代中使用Scavenge算法来处理。**Scavenge**是指把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

* 新加入的对象都会被放到对象区域，当对象区域快写满时，就需要进行一次垃圾清理操作。
* 在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成后就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中去，同时，还会把这些对象有序的排列起来，所以这个复制过程也就相当于完成了内存整理操作，复制后，空闲区域就没有内存碎片了。
* 完成复制后，对象区域与空闲区域进行角色转换，从而完成垃圾对象的回收操作。这种角色翻转的操作可以无限重复下去。

==1 复制操作需要时间成本，为了执行效率，一般新生区空间会设置的小一点。==
==2 经过两次垃圾回收依然还存活的对象，会被移入老生区。这就是JavaScript引擎采取的**对象晋升策略**。==

### 主垃圾回收器
> 主垃圾回收器主要负责老生区中的垃圾回收，采用**标记-清除(Mark-Sweep)**算法进行垃圾回收

* **标记过程：** 从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素被判断为**垃圾数据**。

之后有三种策略处理数据
* 标记-清除
* 标记-整理
* 全停顿
* 增量标记算法

---

# 编译器和解释器

> 编译型语言在程序执行前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要重新编译

> 由解释型语言编写的程序，在每次运行时都需要经过解释器对程序进行动态解释和执行。`Python`和`JavaScript`都属于解释型语言。

编译器和解释器的工作原理如下图所示
@import "../images/3-3-1.png"
* 编译型语言编译过程中，编译器会首先依次对源代码进行词法分析、语法分析，生成抽象语法树，然后是优化代码。最后再生成处理器能理解的机器码。如果编译成功，将会生成一个可执行的新文件。如果编译发生了语法或其它错误，则会抛出异常，并且也不会生成二进制文件
* 解释型语言解释过程中，解释器也会对源代码进行词法分析、语法分析、并生成抽象语法树，不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序，输出结果。

## V8引擎执行代码的流程
@import "../images/3-3-2.png"

### 1. 生成抽象语法树(AST)和执行上下文

> AST是编译器或解释器可以理解的语言。

> 执行上下文是函数调用栈

```javascript
var myName = "极客时间"
function foo(){
  return 23;
}
myName = "geektime"
foo()
```
上面代码转成AST结构示意图如下：
@import "../images/3-3-3.png"

* *Babel的工作原理是*是先将ES6源码转换为AST，然后再将ES6语法的AST转化为ES5语法的AST，最后再利用ES5语法的AST生成JavaScript的源代码
* *ESlint的工作原理是将源码转换为AST，然后再利用AST来检查代码规范化的问题*

#### AST的生成过程是分词和解析
* 分词：将一行行的源代码拆解成一个个token（指语法上不可能再分的、最小的字符或字符串）
* 解析：将上一步生成的token数据，根据语法规则转换成AST

**有了AST后，V8就会生成该段代码的执行上下文**

### 2. 生成字节码
有了AST和执行上下文之后，解释器Ignition会根据AST生成字节码，并解释执行字节码。

> 字节码是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

### 3. 执行代码
解释器Ignition会逐条解释执行字节码。但是在这个过程中，如果发现有热点代码（一段代码被重复执行多次），那么后台编译器TurboFan就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行被编译后的机器码就可以了。这样大大提升了代码的执行效率。


字节码配合解释器和编译器的技术被称为**即时编译（JIT）**，其工作过程如下图所示：
@import "../images/3-3-4.png"



