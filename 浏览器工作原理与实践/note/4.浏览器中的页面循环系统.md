# 消息队列和事件循环
![线程运行模型图](../images/4-1-1.png)

* 引入**事件循环机制**实现了在线程运行过程中，能接收并执行新的任务
* **队列**是一种先进先出的数据结构。主线程会循环地从消息队列头部中读取和执行任务
* IO线程会把产生的新任务添加到消息队列尾部
* 消息队列中的任务被称为**宏任务**，每个宏任务中都包含了一个**微任务队列**
* 使用JavaScript的**回调功能**来解决单个任务执行时间过长的问题

---

# WebAPI：setTimeout
> `setTimeout`是一个用来指定某个函数在多少毫秒之后执行的定时器，返回一个整数，表示定时器的编号。我们可以通过该编号来取消定时器。

**当调用`setTimeout`设置回调函数的时候，渲染进程会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间。创建号回调任务之后，再将该任务添加到==延迟队列==中**

延迟队列的执行时机：每当主线程执行完一个消息队列中的任务后，就会依次执行延迟队列中到期的任务。延迟队列和消息队列是并列关系，不是包含关系。

`setTimeout`的==注意事项==：
* **当前任务执行时间过久，会影响定时器任务的执行**
* **`setTimeout`存在嵌套调用，那么系统会设置最短时间间隔为4毫秒**。在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒
* **未激活的页面，`setTimeout`执行间隔最小时间是1000毫秒**
* **延迟执行时间有最大值**
* **回调函数如果是一个对象的方法时，其中的`this`指向`window`**。可以通过将对象方法放入匿名函数或者箭头函数中执行，或者使用`bind`方法绑定对象。

---

# WebApi：XMLHttpRequest
![XMLHttpRequest运作机制图](../images/4-3-1.png)

XMLHttpRequest发送请求的流程：
* **第一步：创建XMLHttpRequest对象**
* **第二步：为xhr对象注册回调函数**
&nbsp;&nbsp;&nbsp;回调函数有下面几种：
    * `ontimeout`：用来监控超时请求
    * `onerror`：用来监控出错信息
    * `onreadystatechange`：用来监控后台请求过程中的状态
* **第三步：配置基础的请求信息**
* **第四步：发起请求**

--- 
# 宏任务和微任务

> **宏任务**：为了主线程可以有条不紊的执行任务，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通消息队列。这些消息队列中的任务呗统称为**宏任务**。

> **微任务**：是一个需要异步执行的函数，执行时机是在主函数执行结束之后，当前宏任务结束之前。

> **微任务队列**：V8在为一段代码创建全局执行上下文的时候也会在内部创建一个微任务队列，用以存放产生的微任务。

微任务的产生有两种方式：
* 使用`MutationObserver`监控DOM节点，然后通过JS修改节点，当DOM节点发生变化时，就会产生DOM变化记录的微任务
* 使用`Promise`，使用`Promise.resolve()`或者`Promise.reject()`时，也会产生微任务

**微任务总结**
* 微任务和宏任务是绑定的，每个宏任务执行时，会创建自己的微任务队列
* 微任务的执行时长会影响到当前宏任务的执行时长，因为微任务的执行时机在宏任务未结束之前，所以微任务的执行时长包含在宏任务的执行时长内
* 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务。因为创建的宏任务会被放入消息队列队尾等待执行，而微任务则会被置于当前宏任务关联的微任务队列的队尾等待执行。

# async/await

> `async`是一个通过**异步执行**并**隐式返回Promise**作为结果的函数

```javascript
async function foo() {
    return 2
}
console.log(foo())  // Promise {<resolved>: 2}
```

> `await`会默认创建一个`Promise`对象，并且在创建过程中，会调用`resolve`函数，然后V8引擎会将该任务提交给微任务队列
