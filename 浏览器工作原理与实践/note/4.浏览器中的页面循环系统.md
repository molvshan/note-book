# 消息队列和事件循环
![线程运行模型图](../images/4-1-1.png)

* 引入**事件循环机制**实现了在线程运行过程中，能接收并执行新的任务
* **队列**是一种先进先出的数据结构。主线程会循环地从消息队列头部中读取和执行任务
* IO线程会把产生的新任务添加到消息队列尾部
* 消息队列中的任务被称为**宏任务**，每个宏任务中都包含了一个**微任务队列**
* 使用JavaScript的**回调功能**来解决单个任务执行时间过长的问题

---

# WebAPI：setTimeout
> `setTimeout`是一个用来指定某个函数在多少毫秒之后执行的定时器，返回一个整数，表示定时器的编号。我们可以通过该编号来取消定时器。

**当调用`setTimeout`设置回调函数的时候，渲染进程会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间。创建号回调任务之后，再将该任务添加到==延迟队列==中**

延迟队列的执行时机：每当主线程执行完一个消息队列中的任务后，就会依次执行延迟队列中到期的任务。延迟队列和消息队列是并列关系，不是包含关系。

`setTimeout`的==注意事项==：
* **当前任务执行时间过久，会影响定时器任务的执行**
* **`setTimeout`存在嵌套调用，那么系统会设置最短时间间隔为4毫秒**。在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒
* **未激活的页面，`setTimeout`执行间隔最小时间是1000毫秒**
* **延迟执行时间有最大值**
* **回调函数如果是一个对象的方法时，其中的`this`指向`window`**。可以通过将对象方法放入匿名函数或者箭头函数中执行，或者使用`bind`方法绑定对象。

---

# WebApi：XMLHttpRequest
![XMLHttpRequest运作机制图](../images/4-3-1.png)

