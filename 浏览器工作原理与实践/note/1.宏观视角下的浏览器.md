# 目录
* [一、Chrome架构](#cata1)
* [二、TCP/IP工作流程](#cata2)
* [三、HTTP请求流程](#cata3)
* [四、导航流程](#cata4)

---

# <a id="cata1"></a>一、Chrome架构
最新的`chrome`浏览器包含的进程：

* **浏览器进程：** 主要负责界面显示、用户交互、子进程管理、同时提供存储功能。
* **渲染进程：** 核心任务是将`HTML`、`CSS`和`JavaScript`转换为用户可以与之交互的网页，排版引擎`Blink`和`JavaScript`引擎`V8`都是运行在该进程中，默认情况下，`chrome`会为每个`Tab`创建一个渲染进程。处于安全考虑，渲染进程都是运行在沙箱模式下。
* **GPU进程：** `GPU`的使用初衷是为了实现`3D CSS`的效果，只是随后网页、`Chrome`的`UI`界面都选择采用`GPU`来绘制，这使得`GPU`成为浏览器的普遍需求。最后`Chrome`在其多进程架构上引入了`GPU`进程。
* **网络进程：** 主要负责页面的网络资源加载，之前是作为一个模型运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
* **插件进程：** 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

---

# <a id="cata2"></a>二、TCP/IP工作流程
* **IP(Internet Protocol)：网际协议标准**

    计算机的地址就是IP地址，访问任何网站实际上只是一台计算机向另一台计算机请求信息
    
    > 如果想要把一个数据包从主机A发送给主机B，那么在传输之前，数据包会被附加上主机B的IP地址信息，额外的，数据包还会附加上主机A的IP地址，有了这些信息，主机A和B才能互相通信。这些附加的信息会被装进一个叫IP头的数据结构里。IP头是IP数据包开头的信息，包含IP版本、源IP地址、目标IP地址、生存时间等信息。如果要详细了解IP头信息，可以点击[此处](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
    
* **UDP(User Datagram Protocol)：用户数据包协议**

    IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包发给正确的程序
    
    > UDP中一个最重要的信息就是**端口号**。端口号其实是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号，UDP就能把指定的数据包发送给指定的程序了。和IP头一样，端口号会被装进UDP头里，UDP头和原始数据包合并组成新的UDP数据包。UDP头中除了目的端口还有源端口号等信息。
    
    ==数据包在传输过程中容易丢失。==
    
    ==无法将被拆分后的小数据包还原成完整文件==
* **TCP(Transmission Control Protocol)：传输控制协议**
    
    TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于UDP有下面两个特点：
    
    * 对于数据包丢失的情况，提供重传机制
    * 引入排序包机制，用来保证把乱序的数据包组合成完整文件
    
    完整的TCP连接过程包含三个阶段：
    
    * 建立连接（三次握手）
    * 传输数据（数据包丢失触发重传，接收数据之后触发排序机制）
    * 断开连接（四次挥手）

---

# <a id="cata3"></a>三、HTTP请求流程

**HTTP是一种允许浏览器向服务器获取资源的协议，是WEB基础，** 通常由浏览器发起请求，用来获取不同类型的文件（HTML文件、CSS文件、JS文件、图片、视频等），而且**HTTP也是浏览器使用最广的协议**

* 浏览器端发起HTTP请求流程
    * **构建请求**
        浏览器构建请求信息如下所示，构建好后准备发起网络请求。
        <pre>GET /index.html HTTP1.1</pre>
    * **查找缓存**
        浏览器缓存是一种在本地保存资源副本、以供下次请求时直接使用的技术，在真正发起网络请求前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
    * **准备IP地址和端口**
        浏览器使用**HTTP协议作为应用层协议，**用来封装请求的文本信息；并使用**TCP/IP作传输层协议**将它发到网络上，所以在HTTP开始工作之前，浏览器需要通过TCP与服务器建立连接。也就是说**HTTP的内容是通过TCP的传输数据阶段来实现的**，所以，此时从url中获取IP地址(DNS即 Domain Names System域名系统)和端口号用于建立TCP连接
    * **等待TCP队列**
        Chrome浏览器中，同一个域名同时，最多只能建立6个TCP连接，超过6个的请求会进入队列等待其它请求执行完成后再执行，如果少于6个请求，则会直接跳过此步骤。
    * **建立TCP连接**
    * **发送HTTP请求**
        建立TCP连接之后，浏览器就可以和服务器进行通信了
        一个完整的HTTP请求包含**请求行**、**请求头** 、**请求体**三个部分
        * 请求行包括了请求方法、请求URI(Uniform Resource Identifier)和HTTP协议
        * 当使用POST请求方法时，参数需要通过请求体来发送
        * 浏览器发送请求行命令之后，还要以请求头形式发送一些其它信息通知服务器。比如包含了浏览器所使用的操作系统、浏览器内核、当前请求的域名信息、浏览器端的cookie信息等
        @import "../images/request.png"
* 服务器端处理HTTP请求流程
    * **返回请求**
        返回请求包含**响应行**、**响应头**、**响应体**
        * 响应行包含协议版本和状态码
        * 随后服务器会随同响应发送响应头，响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型(JSON、HTML、流媒体类型等)、以及服务器要在客户端保存的cookie信息等
        * 发送完响应头后，服务器就可以继续发送响应体的数据了
        @import "../images/response.png"
    * **断开连接**
        通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接。不过，如果浏览器或者服务器在其头信息中加入了：
        <pre>Connection:Keep-Alive</pre>
        那么，TCP连接在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个TCP连接发送请求。**保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度**
    * **重定向**
        还有一种特殊情况，如果响应状态码是301时，则表示需要重定向到另一个地址，这个地址保存在响应头中的Location字段里
    
---

# <a id="cata4"></a>四、导航流程
@import "../images/liucheng.png"

1. 用户输入
    1. 判断输入的是**搜索内容**还是**URL**。如果是搜索内容，则使用浏览器的默认搜索引擎合成带搜索关键字的URL；如果是URL，则根据规则添加协议，合成完整的URL
    2. 当用户输入完成，键入回车之后，浏览器会执行`beforeunload`事件，用户可以使用这个事件取消导航，终止后续操作
2. 用户输入是在**浏览器进程**中进行的，在用户键入回车之后，浏览器进程会通过IPC(进程间通信)把URL请求发送至网络进程，网络进程接受到URL请求，然后发起真正的URL请求流程
    1. 检查本地是否有缓存资源，如果有，直接返回缓存资源给浏览器进程
    2. 没有查询到缓存资源，则进入网络请求流程，先进行DNS解析，以获取请求域名服务器的IP地址。如果请求协议是HTTPS，则还需要建立TLS连接
    3. 利用IP地址和服务器建立TCP连接。连接建立后，浏览器构建**请求行、请求头、请求体**等信息，然后发送给服务器
    4. 服务器接收到请求后，根据请求信息生成响应数据，并发送给网络进程
    5. 网络进程接受到响应行和响应头后，进行解析
        1. 响应行状态码是**301**或者**302**，网络进程读取响应头中Location字段，进行重定向，然后发起新的HTTP或者HTTPS请求
        2. 相应行状态码是**200**，浏览器继续处理该请求。浏览器根据`Content-Type`的值，决定如何显示响应体的内容。 **Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型**
            * 浏览器判断`Content-Type`值为下载类型时，该请求会被提交给浏览器的下载管理器，同时，该URL请求的导航流程就此结束
            * 浏览器判断`Content-Type`的值为**HTML**时，则会继续执行导航流程
    6. 准备渲染进程
        Chrome默认每个标签对应一个渲染进程。但**如果从当前页面打开一个新页面，且这两个新页面属于同一站点(两个页面的协议和根域名相同)的话，新页面会复用父页面的渲染进程**，如果不属于同一站点的话，则会新打开一个渲染进程。
    7. 浏览器进程将网络进程接收到的HTML数据交给渲染进程。具体步骤如下
        1. 浏览器进程接收到网络进程的响应头数据后，向渲染进程发起“提交文档”的消息
        2. 渲染进程接收到此消息后，和网络进程建立数据传输管道
        3. 文档数据传输完成后，渲染进程返回“确认消息”给浏览器进程
        4. 浏览器进程收到“确认消息”后，更新浏览器界面状态(包括安全状态、地址栏的URL、前进后退的历史状态、更新WEB页面)
    8. 渲染流程
        1. 构建DOM树
        2. 样式计算
            1. 吧CSS转换为浏览器能理解的结构(`document.styleSheets`)
            2. 转换样式表中的属性值，使其标准化
            3. 计算DOM中每个节点的具体样式
        3. 布局阶段（计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局）
            1. 创建布局树（只包含可见元素）
            2. 布局计算
    9. 渲染完成后，渲染进程发送消息通知浏览器进程，浏览器收到消息，停止标签上图标的加载动画
> **重排：** 通过JavaScript或者CSS更改元素的几何位置属性（例如位置，宽高等），浏览器会触发重新布局，开销最大
**重绘：** 修改元素背景颜色等属性会直接进入绘制阶段，执行效率比重排高
**合成：** CSS的`transform`可以避开重排和重绘，直接在非主线程上执行合成动画操作。效率最高

























































